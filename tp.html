<p><strong>Задание помеченных деревьев кодом Прюфера</strong></p><p>Английским математиком А.Кэли (1821-1895) в середине 19 века было доказано, что число помеченных деревьев с n  2  вершинами равно n<sup>n-2</sup>. Немецкий математик Х.Прюфер (1896-1934) предложил способ однозначного кодирования  <em>n</em> - вершинного помеченного дерева упорядоченной последовательностью из <em>n</em>-2 номеров его вершин. Так как число таких последовательностей равно <em>n<sup>n-2</sup></em>, то каждому коду Прюфера можно сопоставить некоторое дерево, и наоборот, то есть между ними существует <a href="https://ru.wikipedia.org/wiki/%D0%91%D0%B8%D0%B5%D0%BA%D1%86%D0%B8%D1%8F">взаимно однозначное соответствие</a>.</p><p><strong>Построение кода Прюфера по дереву</strong></p><p>Достаточно <em>n-2</em> раза выполнить следующую процедуру:</p><ol><li>Выберем в текущем (исходном) дереве висячую вершину с наименьшим номером.  </li><li>Запишем в слово (слева-направо) номер смежной с ней вершины.</li><li> Удалим висячую вершину вместе с инцидентным ребром. </li></ol><p><strong>Пример.</strong> Помеченное 7- вершинное дерево и его код Прюфера </p><p><strong>		     </strong>			      </p><p><strong>				  	</strong>  57517</p><p><strong>	     	              </strong>				</p><p><strong>Построение списка ребер по коду Прюфера</strong></p><p>Запишем вспомогательный массив, содержащий числа от 1 до <em>n </em>и выполним <em> n-2</em> раза следующую процедуру:</p><ol><li>Удалим из вспомогательного массива минимальное число, которого нет в слове (исходном, а затем в текущем).</li><li>Удалим из текущего (исходного) слова первый элемент.</li><li>Составим ребро, концевыми вершинами которого являются вершины с номерами, соответствующими  удаленным числам.</li></ol><p>Последнее (<em>n-1)</em>-ребро составляется из двух вершин с номерами, оставшимися во вспомогательном массиве после выполнения <em>n-2</em> раза предыдущей процедуры.  </p><p>Из всех ребер, отождествляя  вершины с одинаковыми номерами,  конструируется итоговый граф. Покажем, что этот граф не содержит циклов.</p><p>Введем  обозначения:     <em>b<sub>1</sub>b<sub>2</sub>…b<sub>n-2 </sub></em> <strong>-</strong><em><sub> </sub></em> код Прюфера;</p><p><em>   a<sub>1</sub></em> <strong>– </strong>минимальное число, не входящее в <em>b<sub>1</sub>b<sub>2</sub>…b<sub>n-2 </sub></em>, генерируемое ребро <em>(a<sub>1</sub>,b<sub>1</sub>)</em> </p><p><em>   a<sub>2</sub></em> <strong>– </strong>минимальное число, не входящее в <em>b<sub>2</sub> b<sub>3</sub>…b<sub>n-2 </sub></em>, генерируемое ребро <em>(a<sub>2</sub>,b<sub>2</sub>)</em> </p><p><strong>. . .</strong></p><p><em>  a<sub>n-2</sub></em> <strong>– </strong>минимальное число, не совпадающее с <em>b<sub>n-2 </sub></em>, генерируемое ребро <em>(a<sub>n-2</sub>,b<sub>n-2</sub>)</em></p><p><em>(a<sub>n-1</sub>,a<sub>n</sub>)</em><strong> –  </strong>последнее  (<em>n-1)</em>- ребро.</p><p>Ацикличность конструируемого графа покажем индукцией по числу ребер, перечисляя ребра в порядке обратном их генерации:</p><ol><li>Граф с одним ребром <em>(a<sub>n-1</sub>,a<sub>n</sub>), </em>очевидно, не содержит циклов.</li><li>Предположим, что добавление к графу ребер <em>(a<sub>n-2</sub>,b<sub>n-2</sub>),</em>…,<em> (a<sub>n-i</sub>,b<sub>n-i</sub>)</em> не образует циклов.</li><li>Покажем, что добавление к графу ребра <em>(a<sub>n-i-1</sub>,b<sub>n-i-1</sub>)</em> не сможет образовать цикл в текущем графе. Действительно, учитывая  способ генерации ребер, номер <em>a<sub>n-i-1</sub></em> не совпадает ни с одним из номеров <em>b<sub>n-i-1 </sub></em>,<em> b<sub>n-i</sub></em><sub> </sub>,<em>…</em>, <em>b<sub>n-2</sub></em>. Кроме того, числа <em>a<sub>i</sub> a<sub>j</sub></em> при <em>ij</em>. Таким образом, хотя бы одна из концевых вершин добавляемого ребра <em>(a<sub>n-i-1</sub>,b<sub>n-i-1</sub>)</em> не принадлежит уже построенному графу и цикл при этом образоваться не может. <em> </em></li></ol><p>Связность графа покажем методом от противного. Пусть граф содержит <em>k</em> компонент связности. Каждая из них является деревом, поскольку граф не содержит циклов. При этом число вершин <em>n<sub>i</sub></em> и ребер <em>m<sub>i</sub></em> каждой из <em>k</em> компонент  удовлетворяют соотношениям <em>m<sub>i</sub>= n<sub>i</sub>-1</em>. Просуммировав их, имеем следующие равенство , где  и . Таким образом, получаем, что . Но в построенном графе . Следовательно,  и граф содержит лишь одну компоненту связности. 	</p><p>	</p><p><strong>Пример. </strong>Код Прюфера  и восстановленное по нему дерево.</p><p>    73442 							    	              6</p><p>      <em>n=7</em>        <strong>	</strong>(1,7)(3,5)(3,4)(4,6)(2,4)(2,7)	    5       3		2        7      1</p><p>1 2 3 4 5 6 7<em> </em>                                                         			   4	</p><p><strong>Степень оптимальности кода Прюфера</strong></p><p>Пусть  <strong>- </strong>некоторый класс графов, <strong><em><sub>n,m</sub></em></strong><sub> </sub>– подмножество графов из , содержащих <em>n</em> вершин и <em>m</em> ребер; <em>B={0,1}</em>, <em>B-</em>множество слов в алфавите <em>B</em>. <strong><em>Кодированием</em></strong> графов из класса  <strong><em> </em></strong>называется семейство взаимно однозначных отображений <em> = { <sub>n,m </sub>: n=1,2,…; m=1,2,… ;}</em>, где <em> <sub>n,m</sub></em>:<em> </em><strong><em><sub>n,m</sub></em></strong><em> B.</em> Слово из <em>B</em>, сопоставляемое графу <em>G</em><strong><em><sub>n,m</sub></em></strong>, называется <strong><em>кодом</em></strong> графа. Величина <em>| <sub>n,m</sub>(G)|</em> - <strong><em>длина</em></strong> кода графа <em>G</em><strong><em><sub>n,m</sub></em></strong>. При любом способе кодирования имеет место соотношение </p><p><em>log<sub>2</sub>|</em><strong><em><sub>n,m</sub></em></strong><em> | </em><strong><em>  </em></strong><em>max(| <sub>n,m</sub>(G)|, G</em><strong><em><sub>n,m</sub></em></strong><em>)<sub> </sub></em>.<strong><em><sub> </sub></em>  		</strong>(1)</p><p>Для обоснования приведенного соотношения достаточно заметить, что если перечислить в двоичной системе счисления графы из множества  <strong><em><sub>n,m</sub></em></strong>, то наибольшая длина кодов будет не менее <em>log<sub>2</sub>|</em><strong><em><sub>n,m</sub></em></strong>|<em> </em>бит. Поскольку коды графов должны обеспечивать еще и возможность их однозначного восстановления, то это в общем случае потребует дополнительного увеличения длины кода.</p><p>Если в соотношении (1) для любых <em>n</em> и <em>m</em> выполняется равенство, то соответствующее кодирование называется <strong><em>оптимальным</em></strong>. Если имеет место</p><p> ,                      (2)</p><p>то кодирование называется <strong><em>асимптотически оптимальным</em></strong><em>. </em></p><p>Пусть <em>T<sub>n</sub></em> класс всех <em>n</em>- вершинных деревьев<em>. </em>Для графов, являющихся деревьями, будем пользоваться обозначением <em>t, </em>учитывая (1), получаем для деревьев соотношение  </p><p><em>log<sub>2</sub>|T</em><strong><em><sub>n</sub></em></strong><em> |</em> <em>max(| <sub>n</sub>(t)|, tT</em><strong><em><sub>n</sub></em></strong><em>)</em><strong><em><sub> </sub></em></strong><em>.</em></p><p>По теореме Кэли имеем <em>|T<sub>n</sub>|=n<sup>n-2 </sup></em>и следовательно <em>log<sub>2</sub>|T</em><strong><em><sub>n</sub></em></strong><em>| (n-2)log<sub>2 </sub>n</em> . Так как код Прюфера состоит из <em>(n-2)</em> чисел, каждое из которых принадлежит диапазону от 1 до <em>n</em>, то его длина |<em> <sub>n</sub>(t)</em>|  <em>(n-2)log<sub>2 </sub>n</em>. Объединяя оценки, имеем  <em>(n-2)log<sub>2 </sub>n</em>  <em>log<sub>2</sub>|T</em><strong><em><sub>n</sub></em></strong><em> |</em> <em>max(| <sub>n</sub>(t)|, tT</em><strong><em><sub>n</sub></em></strong><em>)</em> <em>(n-2)log<sub>2 </sub>n</em> .</p><p>При этом предел (2) равен единице</p><p>.</p><p>Следовательно, рассмотренное кодирование помеченных деревьев является асимптотически оптимальным. На подпоследовательности <em>n=2<sup>i</sup>, i=1,2,… </em>кодирование является оптимальным.</p>